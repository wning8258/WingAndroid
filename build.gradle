// Top-level build file where you can add configuration options common to all sub-projects/modules.
apply from: this.file('version_config.gradle')
buildscript {
    repositories {
        google()
        jcenter()
        //maven {url "https://dl.bintray.com/wning8258/maven"}
        maven {
            url(localRepo)
        }
    }
    dependencies {
        classpath "com.android.tools.build:gradle:3.6.3"
        classpath 'com.novoda:bintray-release:0.9.2'
        //classpath 声明的依赖，不会编译到最终的 apk 里面
        //bintray停服，导致访问不到了
        classpath 'com.wing.android:asm:0.0.4'
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        google()
        jcenter()
        //maven {url "https://dl.bintray.com/wning8258/maven"}
    }
    tasks.withType(Javadoc) {//解决lib中中文乱码问题
        options.addStringOption('Xdoclint:none', '-quiet')
        options.addStringOption('encoding', 'UTF-8')
        options.addStringOption('charSet', 'UTF-8')
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
/**
 * Gradle脚本的执行分为三个过程：
 *
 * 初始化 init
 * 分析有哪些module将要被构建，为每个module创建对应的 project实例。这个时候settings.gradle文件会被解析。
 *
 * 配置： configure
 * 处理所有的模块的 build 脚本，处理依赖，属性等。这个时候每个模块的build.gradle文件会被解析并配置，
 * 这个时候会构建整个task的链表（这里的链表仅仅指存在依赖关系的task的集合，不是数据结构的链表）。
 *
 * 执行：run
 * 根据task链表来执行某一个特定的task，这个 task所依赖的其他task都将会被提前执行。
 */
/**
 * configure阶段开始前的监听
 * 如果在build.gradle里设置beforeEvaluate会发现里面的代码根本没有被执行，
 * 这是因为在初始化阶段build.gradle文件中的代码根本不会被执行，
 * 执行build.gradle里的配置代码其实已经到了配置阶段，
 * 这种在配置阶段之前执行的代码可以放到~/.gradle/init.d文件夹下的文件里执行，
 * 这样的话这个执行脚本的代码就会成为本机所有工程都会执行的逻辑。
 */
this.beforeEvaluate {  //只监听当前工程的evaluate,监听不到其它工程的，即使是他的子工程
    println "beforeEvaluate"
}
/**
 * configure阶段结束后的监听
 */
this.afterEvaluate {  //只监听当前工程的evaluate,监听不到其它工程的，即使是他的子工程
    println "afterEvaluate"
}
this.gradle.buildFinished {
    println "buildFinished"
}
this.gradle.beforeProject {
    println "beforeProject"
}
this.gradle.afterProject { //等同于afterEvaluate
    println "afterProject"
}
this.gradle.addListener()


/**
 * project相关api
 */
getProjects()

def getProjects() {
    println "...."
    println "Root Project"
    println "...."
    //getAllprojects获取所有的project
    //getSubprojects 获取子projects
    this.getSubprojects()
    this.getAllprojects().eachWithIndex { Project entry, int index ->
        if (index == 0) {
            println "Root project ${entry.name}"
        } else {
            println "sub project ${entry.name}"
        }
    }
    //Root project WingAndroid
    //sub project app
    //sub project module_asm
}

//this.getParentProject()
//
//def getParentProject() {
//    def name = this.getParent().name
//    println "the parent project name is ${name}"
//}
//> Cannot get property 'name' on null object
/**
 * getParent为空，因为他是root project
 */

this.getRootProjects()

def getRootProjects() {
    def name = this.getRootProject().name
    println this.getProject().getName() +"  ,the root project name is ${name}"
    //WingAndroid  ,the root project name is WingAndroid
}

/**
 * =======================================================
 * project api讲解
 */
this.project("app") { Project project ->
    println("project api project name is :${project.name},group is ${project.group}")
    apply plugin: "com.android.application"
    group "com.test"
    version "1.0.0-release"
    dependencies {

    }
    android {

    }
}

this.project("module_asm") {
    //apply plugin: "com.android.library"
    group "com.test"
}
//allprojects是对全局project的配置
allprojects {
   group "com.test2"
}

println "module_asm group is ${project("module_asm").group}"
//subprojects只是对子project的配置
subprojects { Project project ->
    if (project.plugins.hasPlugin("com.android.library")) {  //表明是一个库工程
        println("${project.name} is a android library module")
    }
}

/**
 * 为所有子工程定义ext属性(仍然会在每个子project中定义)
 */
//subprojects {
//    ext {
//        targetSdkVersion1 = 29
//    }
//}
/**
 * 在根工程中，定义ext （只在root project中定义，sub project会继承）
 */
//ext {
//    targetSdkVersion1 = 29
//}

println "isIncludeModuleGroovy :" + isIncludeModuleGroovy.class  //class java.lang.String
